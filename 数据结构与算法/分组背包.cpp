//把背包容量放在第二层枚举保证了不论现在是组内哪一个元素，我们当前的背包容量都是一样的
//这样往前回溯的最大值只能是容量再外层循环出现的最大值————也就是上一组在每个容量下的最大值
//也就是说，为了保证每组的物品只选一个，这个循环保证了每一个容量都会让所有物品依次竞争一遍
//大了会覆盖（因为是覆盖，所以不会选择多个物品，一定是单个最大值之间的覆盖）
//也就是这道题要在意循环的条件：
//普通的背包物品再外层，容量在里层，实现每个物品之和实现最大值
//而这里看到每个组只能选一个，和单个物品的特征类似，嵌套到外层
//然后里层每个物品只有一个重量，通过再一个枚举循环找出符合条件的一组的最大值然后当成那个物品的值
//也就是远看其实只有两层循环，第三层是把一个组的物品搞出一个最大值然后抽象成01背包问题里面单个的物品价值重量的
#include<iostream>
using namespace std;
const int V=210,N=35,T=15;
int w[T][N],v[T][N],s[T];
int f[N];

int main()
{
    int m,n,t;
    cin>>m>>n>>t;
    for(int i=1;i<=n;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        s[z]++;
        w[z][s[z]]=x;
        v[z][s[z]]=y;
    }
    for(int i=1;i<=t;i++)
    {
        for(int j=m;j>=1;j--)
        {
            for(int k=1;k<=s[i];k++)
            {
                if(j>=w[i][k]) f[j]=max(f[j],f[j-w[i][k]]+v[i][k]);
            }
        }
    }
    cout<<f[m];
}
